extern crate alloc;

/// This module is auto-generated by the `raves_metadata_types` crate.
///
/// Please don't hand-edit. Instead, modify the code generation in `build.rs`.
pub mod iptc {
    include!(concat!(env!("OUT_DIR"), "/iptc_keys.rs"));
}

pub mod exif;

pub mod xmp_parse_table;

/// This is the "data" side of things.
///
/// When parsing data out of XMP, these types, alongside the original document,
/// are stored for user discoverability.
pub mod xmp {
    use ::alloc::{boxed::Box, vec::Vec};

    /// An element parsed from the XMP.
    ///
    /// Contains identifiers and a value.
    #[derive(Clone, Debug, PartialEq, PartialOrd)]
    pub struct XmpElement {
        pub namespace: String,
        pub prefix: String,
        pub name: String,

        pub value: XmpValue,
    }

    /// All the possible types an XMP value may have.
    #[derive(Clone, Debug, PartialEq, PartialOrd)]
    pub enum XmpValue {
        Simple(XmpPrimitive),
        Struct(Vec<XmpValueStructField>),

        /// A union is similar to a struct, but its tag determines which fields
        /// are stored at the moment.
        Union {
            /// A field that acts as the discriminant (tag) on this union.
            ///
            /// It says which fields are available.
            ///
            /// Note that the discriminant, unlike the internal parser types,
            /// is NOT included in the `always` field - it's only here.
            discriminant: Box<XmpValueStructField>,

            /// Fields for this discriminant.
            expected_fields: Vec<XmpValueStructField>,

            /// Fields that were not expected for this discriminant, but were
            /// present nonetheless.
            unexpected_fields: Vec<XmpValueStructField>,
        },

        // different array types
        UnorderedArray(Vec<XmpElement>),
        OrderedArray(Vec<XmpElement>),
        Alternatives {
            /// In `(default_key, default_value)` form.
            ///
            /// This is the "chosen" (default) value in the list of
            /// alternatives.
            chosen: (String, Box<XmpElement>),

            /// This is the full list of alternatives.
            ///
            /// Each entry is a `(key, value)` pair.
            list: Vec<(String, XmpElement)>,
        },
    }

    /// One field of an XMP struct.
    #[derive(Clone, Debug, PartialEq, PartialOrd)]
    pub enum XmpValueStructField {
        /// Used when a field has additional inner elements (multiple fields)
        /// as opposed to one primitive value.
        ///
        /// In other words, the contained value isn't a primitive.
        Element {
            /// The field's name.
            ident: String,

            /// The field's namespace.
            namespace: Option<String>,

            /// The field's idents + value.
            element: XmpElement,
        },

        /// Used when a contained value isn't recursive - it's just a
        /// primitive.
        Value {
            /// The field's name.
            ident: String,

            /// The field's namespace.
            namespace: Option<String>,

            /// The field's value.
            value: XmpValue,
        },
    }

    impl XmpValueStructField {
        /// Grabs a struct field's identifier.
        pub fn ident(&self) -> &String {
            match self {
                XmpValueStructField::Element { ident, .. }
                | XmpValueStructField::Value { ident, .. } => ident,
            }
        }

        /// Grabs a struct field's namespace.
        pub fn namespace(&self) -> Option<&String> {
            match self {
                XmpValueStructField::Element { namespace, .. }
                | XmpValueStructField::Value { namespace, .. } => namespace.as_ref(),
            }
        }
    }

    /// XMP structures can use these primitive types.
    #[derive(Clone, Debug, PartialEq, PartialOrd)]
    pub enum XmpPrimitive {
        Boolean(bool),
        Date(String),

        // TODO: technically, these can store infinite digits. should we
        // implement that?
        //
        // imv, we could try `i128`. I'm not sure if anyone has ever used the
        // "infinite digits" property of this type, though. other parsers don't
        // seem to respect it.
        Integer(i64),

        Real(f64),
        Text(String),
    }
}

/// Types from XMP - without values.
///
/// These are used to parse. When we find a value in the XML, we'll give the
/// `XMP_PARSING_MAP` its namespace, then continue parsing based on the type
/// structure defined in the return value.
///
/// If the type we're parsing isn't in the map, we'll instead continue parsing
/// everything duck-typed - all values are text, `rdf` collection types are
/// parsed into their list types, and structs are parsed out without warning
/// on unknown fields.
///
/// The structure created for the parser is somewhat similar to ExifTool's
/// tables, though, here, it's built primarily through the compiler - these are
/// all zero-sized types (ZSTs)!
pub mod xmp_parsing_types {
    /// A specific "kind" of type that a property may be.
    #[derive(Clone, Debug, PartialEq, PartialOrd)]
    pub enum XmpKind {
        /// Contains a primitive type - nothing more.
        ///
        /// Most people call these primitives, but Adobe tends to refer to
        /// these as the "Simple" types.
        Simple(XmpPrimitiveKind),

        /// A struct contains a set of fields.
        ///
        /// Each field in its array contains an identifier and a type.
        Struct(&'static [XmpKindStructField]),

        /// A union of fields that only appears for one variant.
        ///
        /// Note that representing this in the value form (`xmp` module) isn't
        /// useful, as we're only going to parse out its fields.
        ///
        /// However, knowing that a specific property is intended to have only
        /// a specific set of fields can improve error messages.
        Union {
            /// A list of fields that are always present.
            always: &'static [XmpKindStructField],

            /// A field that acts as the discriminant on this union.
            ///
            /// Note that it's currently assumed that this field is a Text
            /// type, as that's what is stored as the discriminant for each
            /// optional pair below.
            discriminant: XmpKindStructField,

            /// Fields that might be present.
            ///
            /// Each entry in the top-level array is a tuple:
            /// `(discriminant, [list of fields for this discriminant])`
            ///
            /// Note that the discriminant **IS A VALUE** - we're required to
            /// tell each variant apart!
            optional: &'static [(&'static str, &'static [XmpKindStructField])],
        },

        /// A struct with:
        ///
        /// 1. a list of required fields (if any), and
        /// 2. unspecified fields.
        ///
        /// This is required for `xmpMM:Pantry`, which contains an "unordered
        /// array of struct" with each struct containing "a potentially unique
        /// set of fields."
        ///
        /// In parsing, this is treated like a wildcard: we grab all fields as
        /// needed, each as data structures containing text, or text itself.
        StructUnspecifiedFields {
            required_fields: &'static [XmpKindStructField],
        },

        // list types
        /// An unordered array can be modified to have any order without
        /// affecting the metadata's meaning.
        ///
        /// In XML, this is represented by an `rdf:Bag` tag.
        UnorderedArray(&'static XmpKind),

        /// We must maintain the order of this array to maintain its metadata's
        /// meaning.
        ///
        /// Represented in XML by `rdf:Seq`.
        OrderedArray(&'static XmpKind),

        /// An array where only one of the values should be displayed to a
        /// user.
        ///
        /// In XML, this is `rdf:Alt`.
        Alternatives(&'static XmpKind),
    }

    /// Sorry for the long name, but what you need to know is that some struct
    /// fields have a namespace URI requirement, whereas others don't specify
    /// it.
    ///
    /// Ex: `ResourceRef` specifies that its namespace must be
    /// `http://ns.adobe.com/xap/1.0/sType/ResourceRef#`, while `FrameCount`
    /// makes no suggestion at all.
    #[derive(Clone, Debug, PartialEq, PartialOrd)]
    pub enum XmpKindStructFieldIdent {
        /// The field uses its parent's namespace.
        ParentNs(&'static str),

        /// The field doesn't have any namespace.
        NoNs(&'static str),

        /// This field requires a specific namespace!
        Namespaced {
            field_name: &'static str,
            namespace: &'static str,
        },
    }

    impl XmpKindStructFieldIdent {
        pub fn ns(&'static self) -> Option<&'static str> {
            match self {
                XmpKindStructFieldIdent::ParentNs(_) => None,
                XmpKindStructFieldIdent::NoNs(_) => None,
                XmpKindStructFieldIdent::Namespaced { namespace, .. } => Some(namespace),
            }
        }

        pub fn name(&'static self) -> &'static str {
            match self {
                XmpKindStructFieldIdent::ParentNs(name)
                | XmpKindStructFieldIdent::NoNs(name)
                | XmpKindStructFieldIdent::Namespaced {
                    field_name: name, ..
                } => name,
            }
        }
    }

    /// On `XmpKind::Struct`, you can have multiple variants.
    ///
    /// This struct represents one such variant.
    #[derive(Clone, Debug, PartialEq, PartialOrd)]
    pub struct XmpKindStructField {
        pub ident: XmpKindStructFieldIdent,
        pub ty: &'static XmpKind,
    }

    /// The XMP standard comes with a modest number of primitives.
    ///
    /// This is a full list of them.
    #[derive(Clone, Debug, PartialEq, PartialOrd)]
    pub enum XmpPrimitiveKind {
        Boolean,
        Date,
        Integer,
        Real,
        Text,
    }
}
