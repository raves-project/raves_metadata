extern crate alloc;

/// This module is auto-generated by the `raves_metadata_types` crate.
///
/// Please don't hand-edit. Instead, modify the code generation in `build.rs`.
pub mod iptc {
    include!(concat!(env!("OUT_DIR"), "/iptc_keys.rs"));
}
/// This is the "data" side of things.
///
/// When parsing data out of XMP, these types, alongside the original document,
/// are stored for user discoverability.
pub mod xmp {
    use ::alloc::{borrow::Cow, boxed::Box, vec::Vec};

    /// All the possible types an XMP value may have.
    #[derive(Clone, Debug, PartialEq, PartialOrd)]
    pub enum XmpValue<'xml> {
        Simple(XmpPrimitive<'xml>),
        Struct(Vec<XmpValueStructField<'xml>>),

        // different array types
        UnorderedArray(Vec<XmpValue<'xml>>),
        OrderedArray(Vec<XmpValue<'xml>>),
        Alternatives {
            chosen: Box<XmpValue<'xml>>,
            list: Vec<XmpValue<'xml>>,
        },
    }

    /// One field of an XMP struct.
    #[derive(Clone, Debug, PartialEq, PartialOrd)]
    pub struct XmpValueStructField<'xml> {
        /// The field's name.
        pub ident: Cow<'xml, str>,

        /// The field's value.
        pub value: XmpValue<'xml>,
    }

    /// XMP structures can use these primitive types.
    #[derive(Clone, Debug, PartialEq, PartialOrd)]
    pub enum XmpPrimitive<'xml> {
        Boolean(bool),
        Date(Cow<'xml, str>),

        // TODO: technically, these can store infinite digits. should we
        // implement that?
        //
        // imv, we could try `i128`. I'm not sure if anyone has ever used the
        // "infinite digits" property of this type, though. other parsers don't
        // seem to respect it.
        Integer(i64),

        Real(f64),
        Text(Cow<'xml, str>),
    }
}

/// Types from XMP - without values.
///
/// These are used to parse. When we find a value in the XML, we'll give the
/// `XMP_PARSING_MAP` its namespace, then continue parsing based on the type
/// structure defined in the return value.
///
/// If the type we're parsing isn't in the map, we'll instead continue parsing
/// everything duck-typed - all values are text, `rdf` collection types are
/// parsed into their list types, and structs are parsed out without warning
/// on unknown fields.
///
/// The structure created for the parser is somewhat similar to ExifTool's
/// tables, though, here, it's built primarily through the compiler - these are
/// all zero-sized types (ZSTs)!
pub mod xmp_parsing_types {
    /// A specific "kind" of type that a property may be.
    #[derive(Debug, PartialEq, PartialOrd)]
    pub enum XmpKind {
        /// Contains a primitive type - nothing more.
        ///
        /// Most people call these primitives, but Adobe tends to refer to
        /// these as the "Simple" types.
        Simple(XmpPrimitiveKind),

        /// A struct contains a set of fields.
        ///
        /// Each field in its array contains an identifier and a type.
        Struct(&'static [XmpKindStructField]),

        /// A union of fields that only appears for one variant.
        ///
        /// Note that representing this in the value form (`xmp` module) isn't
        /// useful, as we're only going to parse out its fields.
        ///
        /// However, knowing that a specific property is intended to have only
        /// a specific set of fields can improve error messages.
        Union {
            /// A list of fields that are always present.
            always: &'static [XmpKindStructField],

            /// A field that acts as the discriminant on this union.
            ///
            /// Note that it's currently assumed that this field is a Text
            /// type, as that's what is stored as the discriminant for each
            /// optional pair below.
            discriminant: XmpKindStructField,

            /// Fields that might be present.
            ///
            /// Each entry in the top-level array is a tuple:
            /// `(discriminant, [list of fields for this discriminant])`
            ///
            /// Note that the discriminant **IS A VALUE** - we're required to
            /// tell each variant apart!
            optional: &'static [(&'static str, &'static [XmpKindStructField])],
        },

        /// A struct with:
        ///
        /// 1. a list of required fields (if any), and
        /// 2. unspecified fields.
        ///
        /// This is required for `xmpMM:Pantry`, which contains an "unordered
        /// array of struct" with each struct containing "a potentially unique
        /// set of fields."
        ///
        /// In parsing, this is treated like a wildcard: we grab all fields as
        /// needed, each as data structures containing text, or text itself.
        StructUnspecifiedFields {
            required_fields: &'static [XmpKindStructField],
        },

        // list types
        /// An unordered array can be modified to have any order without
        /// affecting the metadata's meaning.
        ///
        /// In XML, this is represented by an `rdf:Bag` tag.
        UnorderedArray(&'static XmpKind),

        /// We must maintain the order of this array to maintain its metadata's
        /// meaning.
        ///
        /// Represented in XML by `rdf:Seq`.
        OrderedArray(&'static XmpKind),

        /// An array where only one of the values should be displayed to a
        /// user.
        ///
        /// In XML, this is `rdf:Alt`.
        Alternatives(&'static XmpKind),
    }

    /// Sorry for the long name, but what you need to know is that some struct
    /// fields have a namespace URI requirement, whereas others don't specify
    /// it.
    ///
    /// Ex: `ResourceRef` specifies that its namespace must be
    /// `http://ns.adobe.com/xap/1.0/sType/ResourceRef#`, while `FrameCount`
    /// makes no suggestion at all.
    #[derive(Debug, PartialEq, PartialOrd)]
    pub enum XmpKindStructFieldIdent {
        /// The field uses its parent's namespace.
        ParentNs(&'static str),

        /// The field doesn't have any namespace.
        NoNs(&'static str),

        /// This field requires a specific namespace!
        Namespaced {
            field_name: &'static str,
            namespace: &'static str,
        },
    }

    /// On `XmpKind::Struct`, you can have multiple variants.
    ///
    /// This struct represents one such variant.
    #[derive(Debug, PartialEq, PartialOrd)]
    pub struct XmpKindStructField {
        pub ident: XmpKindStructFieldIdent,
        pub ty: &'static XmpKind,
    }

    /// The XMP standard comes with a modest number of primitives.
    ///
    /// This is a full list of them.
    #[derive(Debug, PartialEq, PartialOrd)]
    pub enum XmpPrimitiveKind {
        Boolean,
        Date,
        Integer,
        Real,
        Text,
    }
}
